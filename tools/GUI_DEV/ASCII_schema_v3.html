<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ASCII Grid Canvas (Vanilla)</title>
 <link rel="stylesheet" href="https://retroapplejs.github.io/tools/GUI_DEV/ASCII_schema.css">
</head>
<body>
  <div class="app">
    <aside id="sidebar" class="sidebar">
      <div class="sb-top">
        <button id="toggleSidebar" class="btn" title="Collapse / Expand" aria-label="Toggle sidebar">◀</button>
        <div id="sbTitle" class="sb-title">ASCII Grid</div>
      </div>
      <div class="sb-content">
        <div class="card">
          <h3>Canvas</h3>
          <div id="cellsLine">Cells: —</div>
          <div id="zoomLine">Zoom: 100%</div>
          <div class="tiny muted" id="coordLine">Cell: —</div>
        </div>

        <div class="card">
          <h3>Mode</h3>
          <div class="row">
            <button id="modeFreeform" class="btn primary">Freeform</button>
            <button id="modeSelect" class="btn">Select &amp; Move</button>
          </div>
          <div id="modeHint" class="tiny muted" style="margin-top:8px;">Drag to draw (cell-by-cell).</div>
        </div>

        <div class="card">
          <h3>Draw</h3>
          <div class="tiny muted">Pick a char or catalog item, then draw / place.</div>
          <div class="row" style="margin-top:10px;">
            <button id="pickChar" class="btn">Char</button>
            <button id="openCatalog" class="btn">Catalog</button>
            <button id="eraser" class="btn">Space</button>
          </div>
          <div class="tiny muted" id="currentOp" style="margin-top:10px;">Current: place '+'</div>
        </div>

        <div class="card">
          <h3>Load &amp; Save</h3>
          <div class="row" style="margin-top:10px;">
            <button id="undoBtn" class="btn" disabled>Undo</button>
            <button id="redoBtn" class="btn" disabled>Redo</button>
            <button id="saveBtn" class="btn">Save</button>
            <button id="loadBtn" class="btn">Load</button>
            <button id="pasteBtn" class="btn">Paste</button>
            <button id="clearBtn" class="btn">Clear</button>
            <input id="fileInput" type="file" accept="text/plain" style="display:none" />
          </div>
          <div class="tiny muted" id="historyLine" style="margin-top:10px;">Undo stack: 0 · Redo stack: 0</div>
          <div class="tiny muted" id="pasteLine" style="margin-top:6px; display:none;">Paste: move preview with mouse, click to place.</div>
        </div>

        <div class="card">
          <div class="tiny muted">Wheel = zoom • Hold mouse button while wheel = pan • Middle-drag = pan</div>
        </div>
      </div>
    </aside>

    <main class="main">
      <div id="container" class="container">
        <div id="stage" class="stage">
          <canvas id="canvas" tabindex="0"></canvas>
        </div>
      </div>
    </main>
  </div>

  <!-- Char Picker -->
  <div id="picker" class="modal" aria-hidden="true">
    <div class="backdrop" id="pickerBackdrop"></div>
    <div class="panel" role="dialog" aria-modal="true" aria-label="Pick a character">
      <div class="panel-top">
        <div style="font-weight:500;">Pick a character</div>
        <button id="pickerClose" class="btn">Close</button>
      </div>
      <div id="tabs" class="tabs"></div>
      <div id="charGrid" class="char-grid"></div>
      <div class="tiny muted" style="margin-top:10px;">Selected: <span id="selectedChar" style="font-weight:500;">+</span></div>
    </div>
  </div>

  <!-- Catalog -->
  <div id="catalogModal" class="modal" aria-hidden="true">
    <div class="backdrop" id="catalogBackdrop"></div>
    <div class="panel" role="dialog" aria-modal="true" aria-label="Catalog">
      <div class="panel-top">
        <div style="font-weight:500;">Catalog</div>
        <button id="catalogClose" class="btn">Close</button>
      </div>
      <div id="catalogTabs" class="tabs"></div>
      <div id="catalogGrid" class="catalog-grid"></div>
      <div class="tiny muted" style="margin-top:10px;">Pick an item → move preview → click to place (clipped).</div>
    </div>
  </div>

  <textarea id="pasteSink" aria-hidden="true"></textarea>

  <script>
  'use strict';

  const COLS = 256;
  const ROWS = 128;
  const GRID_BG = '#FFFFFF';
  const GRID_LINE = '#EEEEEE';
  const MIN_SCALE = 0.5;
  const MAX_SCALE = 10;

  // UI refs
  const sidebar = document.getElementById('sidebar');
  const toggleSidebar = document.getElementById('toggleSidebar');
  const sbTitle = document.getElementById('sbTitle');
  const cellsLine = document.getElementById('cellsLine');
  const zoomLine = document.getElementById('zoomLine');
  const coordLine = document.getElementById('coordLine');
  const modeFreeform = document.getElementById('modeFreeform');
  const modeSelect = document.getElementById('modeSelect');
  const modeHint = document.getElementById('modeHint');
  const pickCharBtn = document.getElementById('pickChar');
  const openCatalogBtn = document.getElementById('openCatalog');
  const eraserBtn = document.getElementById('eraser');
  const currentOpLine = document.getElementById('currentOp');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');
  const pasteBtn = document.getElementById('pasteBtn');
  const clearBtn = document.getElementById('clearBtn');
  const fileInput = document.getElementById('fileInput');
  const historyLine = document.getElementById('historyLine');
  const pasteLine = document.getElementById('pasteLine');

  const container = document.getElementById('container');
  const stage = document.getElementById('stage');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const picker = document.getElementById('picker');
  const pickerBackdrop = document.getElementById('pickerBackdrop');
  const pickerClose = document.getElementById('pickerClose');
  const tabsEl = document.getElementById('tabs');
  const charGrid = document.getElementById('charGrid');
  const selectedCharEl = document.getElementById('selectedChar');

  const catalogModal = document.getElementById('catalogModal');
  const catalogBackdrop = document.getElementById('catalogBackdrop');
  const catalogClose = document.getElementById('catalogClose');
  const catalogTabsEl = document.getElementById('catalogTabs');
  const catalogGridEl = document.getElementById('catalogGrid');

  const pasteSink = document.getElementById('pasteSink');

  // Data model
  const ascii = Array.from({ length: ROWS }, () => Array.from({ length: COLS }, () => ' '));

  // View state
  let sidebarOpen = true;
  let scale = 1;
  let panX = 0;
  let panY = 0;
  let panDrag = null; // {x,y,panX0,panY0}

  // Tool state
  let tool = 'freeform';
  let op = { type: 'place', ch: '+' };
  let hoverCell = null;
  let stageSize = { w: 1, h: 1 };

  let isDrawing = false;
  let lastCellKey = null;
  let currentStroke = [];
  const undoStack = [];
  const redoStack = [];

  let selection = null; // {r0,r1,c0,c1}
  let selectDrag = null; // {start,current}
  let moveDrag = null; // {startCell, offset, baseRect, snapshot}

  let pasteDrag = null; // {lines,w,h,anchor,transparentSpaces}

  // Picker tabs
  let pickerTab = 'Box';
  let catalogTab = 'All';

  // Helpers
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

function normalizeNewlines(t) {
  return String(t ?? "")
    .replace(/\r\n/g, "\n") // real CRLF -> LF
    .replace(/\r/g, "\n");  // real CR   -> LF
}

function toLines(t) {
  return normalizeNewlines(t).split("\n"); // split on real LF
}

  const normRect = (a, b) => ({ r0: Math.min(a.r,b.r), r1: Math.max(a.r,b.r), c0: Math.min(a.c,b.c), c1: Math.max(a.c,b.c) });

  const rangeChars = (start, end) => {
    const out = [];
    for (let cp = start; cp <= end; cp++) out.push(String.fromCharCode(cp));
    return out;
  };

  const PICKER_TABS = {
    Box: rangeChars(0x2500, 0x257F),
    Arrows: rangeChars(0x2190, 0x21FF),
    Geometric: rangeChars(0x25A0, 0x25FF),
    Technical: rangeChars(0x2300, 0x23FF),
    Electronics: ['⏚','⎓','⌁','⊕','⊖','≈','≠','∞','⚠','⚡','⛶','⛝','⛌','⅄','☞','▲','▼','◄','►','^','v','<','>','·','•','⬤'],
  };

  // Hardcoded catalog (extend freely)
  const CATALOG = [
    {
      name: 'ATTiny85',
      type: 'MCU',
      description: '',
      MFR: 'ATTINY85V-10PU',
      pin_data: null,
      text_data:
        '┌───┴─────┴─────┴─────┴───┐\n' +
        '│        @4    @3         │\n' +
        '│╔═ATTiny85══════════════╗│\n' +
        '│║ GND   PB4   PB3   PB5 ║│\n' +
        '│║             TX     ⬤ ║│\n' +
        '│║ SDA                   ║│\n' +
        '│║ MISO  MOSI  SCL       ║│\n' +
        '│║ PB0   PB1   PB2   VCC ║│\n' +
        '│╚═══════════════════════╝│\n' +
        '│  @0    @1    @2         │\n' +
        '└───┬─────┬─────┬─────┬───┘\n',
      image_data:
        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAQMAAACQp+OdAAAAAXNSR0IB2cksfwAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAAAZQTFRFCgkKysnMcoPptgAAAAJ0Uk5TCf1kXfjQAAAAoUlEQVR4nI3OOw7CMBBF0bFSUKamylKyFZYQKkpnac5OYrmgRUoBBeLh+TgiSA64mSPr+kP0uYaCp80GhhajosOs8HjIdIDWBwDWAoHRZ9wYeUrtGC9rwVd2BV4QtGU0Ncx2+k+0NYQ96PFreTSVjzHkq9FwZ1wyFsaZkylj4OQbiyIhKWJuBScfFXQscCumLWiDMBZQFaNBN3YRVtBPyHoDhKEMQVVKl8QAAAAASUVORK5CYII='
    }
  ];

  const catalogTypes = () => Array.from(new Set(CATALOG.map(it => String(it.type || 'Other')))).sort();
  const catalogItemsForTab = (tab) => tab === 'All' ? CATALOG : CATALOG.filter(it => String(it.type || 'Other') === tab);

  // Stage sizing: ensure integer cell sizes (avoid remainder pixels -> spacing artifacts)
  function computeStageSize() {
    const r = container.getBoundingClientRect();
    let w = Math.max(1, Math.floor(r.width));
    let h = Math.max(1, Math.floor(r.height));
    if (w >= COLS) w = Math.floor(w / COLS) * COLS;
    if (h >= ROWS) h = Math.floor(h / ROWS) * ROWS;
    return { w: Math.max(1, w), h: Math.max(1, h) };
  }

  function syncCanvasBufferToStage() {
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(1, Math.floor(stageSize.w * dpr));
    const h = Math.max(1, Math.floor(stageSize.h * dpr));
    if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
  }

  const getCellSize = () => ({ cw: stageSize.w / COLS, ch: stageSize.h / ROWS });

  function getSnapFns(dpr, scaleNow) {
    const pxScale = (dpr || 1) * (scaleNow || 1);
    const snap = (v) => Math.round(v * pxScale) / pxScale;
    const snapLine = (v) => (Math.round(v * pxScale) + 0.5) / pxScale;
    return { snap, snapLine };
  }

  function canvasPointToCell(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const px = ((clientX - rect.left) * stageSize.w) / rect.width;
    const py = ((clientY - rect.top) * stageSize.h) / rect.height;
    const cx = stageSize.w / 2;
    const cy = stageSize.h / 2;
    const ux = (px - cx) / scale + cx - panX;
    const uy = (py - cy) / scale + cy - panY;
    const { cw, ch } = getCellSize();
    const c = Math.floor(ux / cw);
    const r = Math.floor(uy / ch);
    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return null;
    return { r, c };
  }

  function updateUI() {
    cellsLine.textContent = 'Cells: ' + COLS + ' × ' + ROWS;
    zoomLine.textContent = 'Zoom: ' + Math.round(scale * 100) + '%';
    coordLine.textContent = hoverCell ? ('Cell: r ' + hoverCell.r + ' · c ' + hoverCell.c + ' (1-based: ' + (hoverCell.r+1) + ', ' + (hoverCell.c+1) + ')') : 'Cell: —';

    pasteLine.style.display = pasteDrag ? 'block' : 'none';

    if (tool === 'freeform') {
      modeFreeform.classList.add('primary');
      modeSelect.classList.remove('primary');
      modeHint.textContent = pasteDrag ? 'Pasting: move preview with mouse, click to place.' : 'Drag to draw (cell-by-cell).';
    } else {
      modeSelect.classList.add('primary');
      modeFreeform.classList.remove('primary');
      modeHint.textContent = pasteDrag ? 'Pasting: move preview with mouse, click to place.' : 'Drag to select. Drag inside selection to move.';
    }

    currentOpLine.textContent = op.type === 'place' ? ('Current: place \' ' + op.ch + ' \'' ) : 'Current: space';
    selectedCharEl.textContent = op.type === 'place' ? op.ch : '(space)';

    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = redoStack.length === 0;
    historyLine.textContent = 'Undo stack: ' + undoStack.length + ' · Redo stack: ' + redoStack.length;

    toggleSidebar.textContent = sidebarOpen ? '◀' : '▶';
    sbTitle.style.display = sidebarOpen ? 'block' : 'none';
  }

  function serializeToText() {
    const lines = [];
    for (let r = 0; r < ROWS; r++) lines.push(ascii[r].join(''));
    return lines.join("\n");
  }

function deEscapeLiteralNewlines(t) {
  return String(t ?? "")
    .replace(/\\r\\n/g, "\n")
    .replace(/\\n/g, "\n")
    .replace(/\\r/g, "\n");
}


  function downloadText(text, filename) {
    const name = filename || 'ascii-drawing.txt';
    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = name;
    a.rel = 'noopener';
    a.style.display = 'none';
    document.body.appendChild(a);
    try { a.click(); } finally { setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0); }
  }

  function pushStrokeIfNonEmpty(stroke) {
    if (!stroke || stroke.length === 0) return;
    undoStack.push(stroke);
    redoStack.length = 0;
    updateUI();
  }

  function doUndo() {
    const stroke = undoStack.pop();
    if (!stroke) return;
    for (let i = stroke.length - 1; i >= 0; i--) ascii[stroke[i].r][stroke[i].c] = stroke[i].prev;
    redoStack.push(stroke);
    updateUI();
    draw();
  }

  function doRedo() {
    const stroke = redoStack.pop();
    if (!stroke) return;
    for (let i = 0; i < stroke.length; i++) ascii[stroke[i].r][stroke[i].c] = stroke[i].next;
    undoStack.push(stroke);
    updateUI();
    draw();
  }

  function snapshotRect(rect) {
    const m = new Map();
    for (let r = rect.r0; r <= rect.r1; r++) for (let c = rect.c0; c <= rect.c1; c++) m.set(r + ',' + c, ascii[r][c]);
    return m;
  }

  // Paste (preview + commit)
  function startPasteWithText(text) {
    const raw = normalizeNewlines(text).split('\n');
    while (raw.length > 0 && raw[raw.length - 1] === '') raw.pop();
    if (raw.length === 0) { pasteDrag = null; updateUI(); draw(); return; }

    let w = 0;
    for (const ln of raw) w = Math.max(w, ln.length);

    const maxH = Math.min(raw.length, ROWS);
    const maxW = Math.min(w, COLS);
    const lines = raw.slice(0, maxH).map(ln => ln.slice(0, maxW));

    pasteDrag = {
      lines,
      h: lines.length,
      w: maxW,
      anchor: hoverCell ? { r: hoverCell.r, c: hoverCell.c } : { r: Math.floor(ROWS/2), c: Math.floor(COLS/2) },
      transparentSpaces: true,
    };

    // Paste mode implies Select tool (so cursor behavior matches your workflow)
    tool = 'select';
    // Clear selection overlay while pasting
    selection = null;
    selectDrag = null;
    moveDrag = null;

    updateUI();
    draw();
  }

  function commitPasteAt(cell) {
    if (!pasteDrag || !cell) return;
    const a = { r: cell.r, c: cell.c };
    const stroke = [];

    for (let rr = 0; rr < pasteDrag.h; rr++) {
      const line = pasteDrag.lines[rr] || '';
      for (let cc = 0; cc < pasteDrag.w; cc++) {
        const chx = line[cc] || ' ';
        if (pasteDrag.transparentSpaces && chx === ' ') continue;
        const tr = a.r + rr;
        const tc = a.c + cc;
        if (tr < 0 || tr >= ROWS || tc < 0 || tc >= COLS) continue; // clip
        const prev = ascii[tr][tc];
        const next = chx;
        if (prev === next) continue;
        stroke.push({ r: tr, c: tc, prev, next });
        ascii[tr][tc] = next;
      }
    }

    pasteDrag = null;
    pushStrokeIfNonEmpty(stroke);
    updateUI();
    draw();
  }

  function cancelPaste() {
    if (!pasteDrag) return;
    pasteDrag = null;
    updateUI();
    draw();
  }

  // Freeform drawing
  function applyOpAtCell(cell) {
    const prev = ascii[cell.r][cell.c];
    const next = (op.type === 'place') ? op.ch : ' ';
    if (prev === next) return;
    currentStroke.push({ r: cell.r, c: cell.c, prev, next });
    ascii[cell.r][cell.c] = next;
  }

  function beginFreeform(cell) {
    isDrawing = true;
    lastCellKey = null;
    currentStroke = [];
    if (!cell) return;
    lastCellKey = cell.r + ',' + cell.c;
    applyOpAtCell(cell);
    draw();
  }

  function moveFreeform(cell) {
    if (!isDrawing || !cell) return;
    const key = cell.r + ',' + cell.c;
    if (key === lastCellKey) return;
    lastCellKey = key;
    applyOpAtCell(cell);
    draw();
  }

  function endFreeform() {
    if (!isDrawing) return;
    isDrawing = false;
    const stroke = currentStroke;
    currentStroke = [];
    lastCellKey = null;
    pushStrokeIfNonEmpty(stroke);
  }

  // Select & move
  function applyMove(baseRect, dr, dc, snapMap) {
    if (dr === 0 && dc === 0) return;
    const stroke = [];

    // Clear base rect
    for (let r = baseRect.r0; r <= baseRect.r1; r++) {
      for (let c = baseRect.c0; c <= baseRect.c1; c++) {
        const prev = ascii[r][c];
        if (prev !== ' ') {
          stroke.push({ r, c, prev, next: ' ' });
          ascii[r][c] = ' ';
        }
      }
    }

    // Paste moved snapshot (clip to grid)
    for (let r = baseRect.r0; r <= baseRect.r1; r++) {
      for (let c = baseRect.c0; c <= baseRect.c1; c++) {
        const chx = snapMap.get(r + ',' + c) || ' ';
        const rr = r + dr;
        const cc = c + dc;
        if (rr < 0 || rr >= ROWS || cc < 0 || cc >= COLS) continue;
        const prev = ascii[rr][cc];
        const next = chx;
        if (prev !== next) {
          stroke.push({ r: rr, c: cc, prev, next });
          ascii[rr][cc] = next;
        }
      }
    }

    pushStrokeIfNonEmpty(stroke);
  }

  function beginSelect(cell) {
    if (!cell) return;

    if (selection && cell.r >= selection.r0 && cell.r <= selection.r1 && cell.c >= selection.c0 && cell.c <= selection.c1) {
      moveDrag = { startCell: cell, offset: { dr: 0, dc: 0 }, baseRect: selection, snapshot: snapshotRect(selection) };
      draw();
      return;
    }

    selection = null;
    moveDrag = null;
    selectDrag = { start: cell, current: cell };
    draw();
  }

  function moveSelect(cell) {
    if (!cell) return;
    if (moveDrag) {
      const dr = cell.r - moveDrag.startCell.r;
      const dc = cell.c - moveDrag.startCell.c;
      if (dr === moveDrag.offset.dr && dc === moveDrag.offset.dc) return;
      moveDrag.offset = { dr, dc };
      draw();
      return;
    }
    if (selectDrag) {
      selectDrag.current = cell;
      draw();
    }
  }

  function endSelect() {
    // Keep selection after selecting; clear after move commit.
    if (moveDrag) {
      const base = moveDrag.baseRect;
      const snapMap = moveDrag.snapshot;
      const { dr, dc } = moveDrag.offset;
      applyMove(base, dr, dc, snapMap);
      moveDrag = null;
      selectDrag = null;
      selection = null; // disappear after move mouseup
      draw();
      return;
    }
    if (selectDrag) {
      selection = normRect(selectDrag.start, selectDrag.current);
      selectDrag = null;
      draw();
    }
  }

  // Modals
  function openPicker() {
    picker.classList.add('open');
    picker.setAttribute('aria-hidden', 'false');
    renderTabs();
    renderCharGrid();
    updateUI();
  }
  function closePicker() {
    picker.classList.remove('open');
    picker.setAttribute('aria-hidden', 'true');
    updateUI();
  }

  function renderTabs() {
    tabsEl.innerHTML = '';
    for (const tab of Object.keys(PICKER_TABS)) {
      const b = document.createElement('button');
      b.className = 'btn' + (tab === pickerTab ? ' primary' : '');
      b.textContent = tab;
      b.addEventListener('click', () => { pickerTab = tab; renderTabs(); renderCharGrid(); });
      tabsEl.appendChild(b);
    }
  }
  function renderCharGrid() {
    charGrid.innerHTML = '';
    const arr = PICKER_TABS[pickerTab] || [];
    for (const ch of arr) {
      const b = document.createElement('button');
      b.className = 'char';
      b.textContent = ch;
      b.title = "Select '" + ch + "'";
      b.addEventListener('click', () => { op = { type: 'place', ch }; closePicker(); updateUI(); });
      charGrid.appendChild(b);
    }
  }

  function openCatalog() {
    catalogModal.classList.add('open');
    catalogModal.setAttribute('aria-hidden', 'false');
    renderCatalogTabs();
    renderCatalogGrid();
    updateUI();
  }
  function closeCatalog() {
    catalogModal.classList.remove('open');
    catalogModal.setAttribute('aria-hidden', 'true');
    updateUI();
  }

  function renderCatalogTabs() {
    catalogTabsEl.innerHTML = '';
    const types = ['All', ...catalogTypes()];
    for (const t of types) {
      const b = document.createElement('button');
      b.className = 'btn' + (t === catalogTab ? ' primary' : '');
      b.textContent = t;
      b.addEventListener('click', () => { catalogTab = t; renderCatalogTabs(); renderCatalogGrid(); });
      catalogTabsEl.appendChild(b);
    }
  }

  function renderCatalogGrid() {
    catalogGridEl.innerHTML = '';
    const items = catalogItemsForTab(catalogTab);
    for (const it of items) {
      const card = document.createElement('div');
      card.className = 'cat-item';
      card.title = it.name + (it.MFR ? (' · ' + it.MFR) : '');

      const img = document.createElement('img');
      img.className = 'cat-thumb';
      img.alt = it.name;
      img.src = it.image_data;

      const cap = document.createElement('div');
      cap.className = 'cat-name';
      cap.textContent = it.name;

      card.appendChild(img);
      card.appendChild(cap);

      card.addEventListener('click', () => {
        closeCatalog();
        startPasteWithText(it.text_data || '');
        canvas.focus();
      });

      catalogGridEl.appendChild(card);
    }
  }

  // Drawing
  function drawPastePreview(cw, ch, snap) {
    if (!pasteDrag || !pasteDrag.anchor) return;
    const a = pasteDrag.anchor;

    // Preview fill (clipped to visible grid)
    const pxW = Math.max(0, Math.min(pasteDrag.w, COLS - a.c)) * cw;
    const pxH = Math.max(0, Math.min(pasteDrag.h, ROWS - a.r)) * ch;
    if (pxW > 0 && pxH > 0) {
      ctx.save();
      ctx.globalAlpha = 0.75;
      ctx.fillStyle = 'rgba(16,185,129,0.10)';
      ctx.fillRect(a.c * cw, a.r * ch, pxW, pxH);
      ctx.restore();
    }

    ctx.save();
    ctx.globalAlpha = 0.9;
    for (let rr = 0; rr < pasteDrag.h; rr++) {
      const line = pasteDrag.lines[rr] || '';
      for (let cc = 0; cc < pasteDrag.w; cc++) {
        const chx = line[cc] || ' ';
        if (pasteDrag.transparentSpaces && chx === ' ') continue;
        const tr = a.r + rr;
        const tc = a.c + cc;
        if (tr < 0 || tr >= ROWS || tc < 0 || tc >= COLS) continue;
        ctx.fillText(chx, snap(tc * cw + cw/2), snap(tr * ch + ch/2));
      }
    }
    ctx.restore();

    ctx.save();
    ctx.lineWidth = 2 / scale;
    ctx.setLineDash([6 / scale, 4 / scale]);
    ctx.strokeStyle = 'rgba(16,185,129,0.95)';
    ctx.strokeRect(a.c * cw, a.r * ch, pasteDrag.w * cw, pasteDrag.h * ch);
    ctx.restore();
  }

  function draw() {
    const dpr = window.devicePixelRatio || 1;
    const { cw, ch } = getCellSize();
    const wCss = stageSize.w;
    const hCss = stageSize.h;

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    ctx.fillStyle = GRID_BG;
    ctx.fillRect(0,0,wCss,hCss);

    const cx = wCss/2, cy = hCss/2;
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);
    ctx.translate(-cx + panX, -cy + panY);

    const { snap, snapLine } = getSnapFns(dpr, scale);

    // Grid lines (pixel-snapped)
    ctx.beginPath();
    ctx.strokeStyle = GRID_LINE;
    ctx.lineWidth = 1 / scale;
    for (let c = 0; c <= COLS; c++) {
      const x = snapLine(c * cw);
      ctx.moveTo(x, 0);
      ctx.lineTo(x, hCss);
    }
    for (let r = 0; r <= ROWS; r++) {
      const y = snapLine(r * ch);
      ctx.moveTo(0, y);
      ctx.lineTo(wCss, y);
    }
    ctx.stroke();

    // Font sized to cell
    ctx.fillStyle = '#000';
    const maxByHeight = ch * 0.98;
    const maxByWidth = (cw / 0.62) * 0.98;
    const fontPx = Math.max(4, Math.floor(Math.min(maxByHeight, maxByWidth)));
    ctx.font = fontPx + 'px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Move preview
    if (moveDrag) {
      const b = moveDrag.baseRect;
      const o = moveDrag.offset;
      const snapMap = moveDrag.snapshot;
      ctx.save();
      ctx.globalAlpha = 0.9;
      for (let r = b.r0; r <= b.r1; r++) {
        for (let c = b.c0; c <= b.c1; c++) {
          const chx = snapMap.get(r + ',' + c) || ' ';
          if (chx === ' ') continue;
          const rr = r + o.dr;
          const cc = c + o.dc;
          if (rr < 0 || rr >= ROWS || cc < 0 || cc >= COLS) continue;
          ctx.fillText(chx, snap(cc * cw + cw/2), snap(rr * ch + ch/2));
        }
      }
      ctx.restore();
    }

    // Draw all chars (skip base rect while moving)
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const chx = ascii[r][c];
        if (chx === ' ') continue;
        if (moveDrag) {
          const b = moveDrag.baseRect;
          if (r >= b.r0 && r <= b.r1 && c >= b.c0 && c <= b.c1) continue;
        }
        ctx.fillText(chx, snap(c * cw + cw/2), snap(r * ch + ch/2));
      }
    }

    // Selection overlay (stays after select; cleared after move mouseup)
    if (selection) {
      const x0 = selection.c0 * cw;
      const y0 = selection.r0 * ch;
      const w = (selection.c1 - selection.c0 + 1) * cw;
      const h = (selection.r1 - selection.r0 + 1) * ch;
      ctx.save();
      ctx.lineWidth = 2 / scale;
      ctx.strokeStyle = 'rgba(59,130,246,0.9)';
      ctx.fillStyle = 'rgba(59,130,246,0.12)';
      ctx.fillRect(x0, y0, w, h);
      ctx.strokeRect(x0, y0, w, h);
      ctx.restore();
    }

    // Drag-select marquee
    if (selectDrag) {
      const rr = normRect(selectDrag.start, selectDrag.current);
      const x0 = rr.c0 * cw;
      const y0 = rr.r0 * ch;
      const w = (rr.c1 - rr.c0 + 1) * cw;
      const h = (rr.r1 - rr.r0 + 1) * ch;
      ctx.save();
      ctx.lineWidth = 2 / scale;
      ctx.setLineDash([6/scale, 4/scale]);
      ctx.strokeStyle = 'rgba(16,185,129,0.95)';
      ctx.strokeRect(x0, y0, w, h);
      ctx.restore();
    }

    if (pasteDrag) drawPastePreview(cw, ch, snap);
  }

  // Events
  function setHoverFromEvent(e) {
    hoverCell = canvasPointToCell(e.clientX, e.clientY);
    if (pasteDrag && hoverCell) pasteDrag.anchor = { r: hoverCell.r, c: hoverCell.c };
    updateUI();
  }

  // Sidebar toggle
  toggleSidebar.addEventListener('click', () => {
    sidebarOpen = !sidebarOpen;
    sidebar.classList.toggle('closed', !sidebarOpen);
    updateUI();
    scheduleResize();
  });

  // Mode buttons
  modeFreeform.addEventListener('click', () => {
    tool = 'freeform';
    // Requirement: selection box disappears in Freeform mode
    selection = null;
    selectDrag = null;
    moveDrag = null;
    updateUI();
    draw();
  });
  modeSelect.addEventListener('click', () => {
    tool = 'select';
    if (isDrawing) endFreeform();
    updateUI();
    draw();
  });

  // Picker/catalog
  pickerBackdrop.addEventListener('click', closePicker);
  pickerClose.addEventListener('click', closePicker);
  catalogBackdrop.addEventListener('click', closeCatalog);
  catalogClose.addEventListener('click', closeCatalog);

  pickCharBtn.addEventListener('click', () => { if (op.type !== 'place') op = { type: 'place', ch: '+' }; openPicker(); });
  openCatalogBtn.addEventListener('click', () => openCatalog());
  eraserBtn.addEventListener('click', () => { op = { type: 'erase' }; updateUI(); });

  // Undo/redo
  undoBtn.addEventListener('click', doUndo);
  redoBtn.addEventListener('click', doRedo);

  // Save/load
  function sanitizeForSave(text) {
  return String(text)
    .replace(/\\r\\n/g, "\n") // literal "\r\n" -> newline
    .replace(/\\n/g, "\n")    // literal "\n" -> newline
    .replace(/\\r/g, "\n");   // literal "\r" -> newline
}

  saveBtn.addEventListener("click", () => {
    const raw = serializeToText();
    const cleaned = deEscapeLiteralNewlines(raw);
    downloadText(cleaned, "ascii-schema.txt");
  });
  loadBtn.addEventListener('click', () => fileInput.click());

  fileInput.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    const text = await file.text();
    const toLines = (t) => normalizeNewlines(t).split("\n"); // ✅ NOT "\\n"
    const stroke = [];
    for (let r = 0; r < ROWS; r++) {
      const line = lines[r] || '';
      for (let c = 0; c < COLS; c++) {
        const prev = ascii[r][c];
        const next = line[c] || ' ';
        if (prev !== next) { stroke.push({ r, c, prev, next }); ascii[r][c] = next; }
      }
    }
    selection = null; selectDrag = null; moveDrag = null; cancelPaste();
    pushStrokeIfNonEmpty(stroke);
    draw();
    fileInput.value = '';
  });

  // Clear
  clearBtn.addEventListener('click', () => {
    const stroke = [];
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const prev = ascii[r][c];
        if (prev !== ' ') { stroke.push({ r, c, prev, next: ' ' }); ascii[r][c] = ' '; }
      }
    }
    selection = null; selectDrag = null; moveDrag = null; cancelPaste();
    pushStrokeIfNonEmpty(stroke);
    draw();
  });

  // Paste button focuses hidden textarea, then user Cmd/Ctrl+V
  pasteBtn.addEventListener('click', () => { pasteSink.value = ''; pasteSink.focus(); });

  // Paste capture (also allow direct paste anywhere)
  window.addEventListener('paste', (e) => {
    const text = e.clipboardData ? e.clipboardData.getData('text/plain') : '';
    if (typeof text === 'string' && text.length > 0) { e.preventDefault(); startPasteWithText(text); canvas.focus(); }
  });
  pasteSink.addEventListener('paste', (e) => {
    const text = e.clipboardData ? e.clipboardData.getData('text/plain') : '';
    if (typeof text === 'string' && text.length > 0) { e.preventDefault(); startPasteWithText(text); canvas.focus(); }
  });

  // Zoom / pan with wheel
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    if (e.buttons && e.buttons !== 0) {
      // KiCad-style: wheel pans while button pressed
      panX += (e.deltaX || 0) / scale;
      panY += (e.deltaY || 0) / scale;
      updateUI();
      draw();
      return;
    }
    const zoomFactor = Math.exp(-e.deltaY * 0.0015);
    scale = clamp(Number((scale * zoomFactor).toFixed(4)), MIN_SCALE, MAX_SCALE);
    updateUI();
    draw();
  }, { passive: false });

  // Mouse
  canvas.addEventListener('mousemove', (e) => {
    if (panDrag) {
      const dx = e.clientX - panDrag.x;
      const dy = e.clientY - panDrag.y;
      panX = panDrag.panX0 + dx / scale;
      panY = panDrag.panY0 + dy / scale;
      setHoverFromEvent(e);
      draw();
      return;
    }

    setHoverFromEvent(e);
    const cell = canvasPointToCell(e.clientX, e.clientY);

    if (pasteDrag) {
      if (cell) pasteDrag.anchor = { r: cell.r, c: cell.c };
      draw();
      return;
    }

    if (tool === 'freeform') moveFreeform(cell);
    else moveSelect(cell);
  });

  canvas.addEventListener('mousedown', (e) => {
    // Middle mouse drag = pan
    if (e.button === 1) {
      e.preventDefault();
      panDrag = { x: e.clientX, y: e.clientY, panX0: panX, panY0: panY };
      canvas.style.cursor = 'grabbing';
      return;
    }

    if (e.button !== 0) return;
    canvas.focus();
    setHoverFromEvent(e);
    const cell = canvasPointToCell(e.clientX, e.clientY);

    if (pasteDrag) { commitPasteAt(cell); return; }

    if (tool === 'freeform') beginFreeform(cell);
    else beginSelect(cell);
  });

  window.addEventListener('mouseup', () => {
    if (panDrag) { panDrag = null; canvas.style.cursor = ''; return; }
    if (pasteDrag) return;
    if (isDrawing) endFreeform();
    if (selectDrag || moveDrag) endSelect();
  });

  canvas.addEventListener('mouseleave', () => {
    if (panDrag) { panDrag = null; canvas.style.cursor = ''; }
    hoverCell = null;
    updateUI();
    if (pasteDrag) return;
    if (isDrawing) endFreeform();
    if (selectDrag || moveDrag) endSelect();
  });

  canvas.addEventListener('contextmenu', (e) => e.preventDefault());

  // Shortcuts
  window.addEventListener('keydown', (e) => {
    const isMac = /mac/i.test(navigator.platform);
    const mod = isMac ? e.metaKey : e.ctrlKey;
    if (e.key === 'Escape') { if (pasteDrag) { e.preventDefault(); cancelPaste(); } return; }
    if (!mod) return;
    const k = String(e.key || '').toLowerCase();
    if (k === 'z' && !e.shiftKey) { e.preventDefault(); doUndo(); }
    else if (k === 'z' && e.shiftKey) { e.preventDefault(); doRedo(); }
    else if (k === 'v') { pasteSink.value = ''; pasteSink.focus(); }
  }, { passive: false });

  // Resize observer (debounced via rAF)
  let resizeRaf = null;
  function scheduleResize() {
    if (resizeRaf != null) return;
    resizeRaf = requestAnimationFrame(() => {
      resizeRaf = null;
      const next = computeStageSize();
      if (next.w === stageSize.w && next.h === stageSize.h) return;
      stageSize = next;
      stage.style.width = stageSize.w + 'px';
      stage.style.height = stageSize.h + 'px';
      syncCanvasBufferToStage();
      draw();
    });
  }

  const ro = new ResizeObserver(() => scheduleResize());
  ro.observe(container);

  // Init
  (function init() {
    stageSize = computeStageSize();
    stage.style.width = stageSize.w + 'px';
    stage.style.height = stageSize.h + 'px';
    syncCanvasBufferToStage();

    // Light sanity checks
    console.assert(serializeToText().split('\n')[0].length === COLS, 'serializeToText -> COLS chars/line');
    console.assert(toLines('A\r\nB\rC\nD').length === 4, 'newline normalization');
    console.assert(!serializeToText().includes("\\n"), "Save must not contain literal \\n");
    updateUI();
    draw();
  })();
  </script>
</body>
</html>
