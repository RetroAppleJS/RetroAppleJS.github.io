<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>UTF8 bitmapper v3 — grayscale convolution compare</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: end; }
    label { display: block; font-size: 12px; opacity: 0.8; margin-bottom: 4px; }
    input, select { font-size: 14px; padding: 6px 8px; }
    button { font-size: 14px; padding: 6px 10px; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    pre, textarea {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 14px;
      line-height: 1.0;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      white-space: pre;
      overflow: auto;
      width: 100%;
      box-sizing: border-box;
    }
    canvas { border: 1px dashed #bbb; border-radius: 8px; image-rendering: pixelated; }
    .status { font-size: 12px; opacity: 0.85; margin-top: 8px; }
    .pill { display: inline-block; padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; margin-left: 6px; }
    .cols { display: flex; gap: 12px; flex-wrap: wrap; }
    .col { flex: 1; min-width: 280px; }

    #outWrap {
    border-radius: 8px;
    }
    #outWrap.blackBlocks {
    background: #fff;
    color: #000;
    }
    #outWrap.whiteBlocks {
    background: #111;
    color: #fff;
    }


  </style>
</head>

<body>
  <h2>Single UTF character → bitmap → block grid</h2>

  <div class="row">
    <div>
      <label>Character (1 code point)</label>
      <input id="txt" value="é" size="6" inputmode="text" autocomplete="off" />
    </div>

    <div>
      <label>Font</label>
      <select id="font">
        <option value="sans">Sans</option>
        <option value="serif">Serif</option>
        <option value="mono">Monospace</option>
      </select>
    </div>

    <div>
      <label>Cell</label>
      <select id="cell">
        <option value="16x32" selected>16×32</option>
        <option value="8x16">8×16</option>
        <option value="32x64">32×64</option>
      </select>
    </div>

    <div>
      <label>Threshold (display only)</label>
      <input id="thr" type="number" value="96" min="0" max="255" style="width: 92px" />
    </div>

    <div>
      <label>Min match %</label>
      <input id="minPct" type="number" value="90" min="0" max="100" step="0.1" style="width: 92px" />
    </div>

    <div>
      <label>&nbsp;</label>
      <button id="copy">Copy grid</button>
    </div>

    <div>
      <label>&nbsp;</label>
      <button id="compare">Compare U+0000..U+1869F</button>
    </div>

    <div>
      <label>&nbsp;</label>
      <button id="cancel" disabled>Cancel</button>
    </div>
  </div>

  <div class="cols" style="margin-top: 14px;">
    <div>
      <label>Canvas preview (actual pixels)</label>
      <canvas id="cv" width="16" height="32"></canvas>
      <div class="status" id="meta"></div>
    </div>

    <div class="col">
    <label>Block grid output</label>

    <div class="row" style="gap:10px; align-items:center; margin-bottom:8px;">
        <div>
        <label style="margin-bottom:2px;">Background char</label>
        <input id="bgChar" value="H" size="2" />
        </div>

        <div>
        <label style="margin-bottom:2px;">Blocks color</label>
        <select id="blockColor">
            <option value="black" selected>Black blocks</option>
            <option value="white">White blocks</option>
        </select>
        </div>
    </div>

    <div id="outWrap">
        <pre id="out"></pre>
    </div>

    <div class="status" id="copyStatus"></div>
    </div>

    <div class="col">
      <label>Compare results (matches ≥ min %)</label>
      <textarea id="results" rows="12" readonly placeholder="Matches will appear here..."></textarea>
      <div class="status" id="cmpStatus"></div>
    </div>
  </div>

<script>
(() => {
  const RANGE_MAX = 0x1869F; // inclusive
  const BLOCKS = [' ', '▀', '▄', '█']; // display only

  const el = (id) => document.getElementById(id);

  const state = {
    comparing: false,
    cancel: false,
    target: null // { w,h,font,ch, grayTarget }
  };

  function parseCell(sel) {
    const [w, h] = sel.split('x').map(n => parseInt(n, 10));
    return { w, h };
  }

  function fontCSS(kind) {
    switch (kind) {
      case "serif": return `serif`;
      case "mono": return `ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace`;
      default: return `system-ui, -apple-system, Segoe UI, sans-serif`;
    }
  }

  // Force input to exactly one Unicode code point (handles surrogate pairs).
  function enforceSingleCodePointInput() {
    const raw = el('txt').value ?? "";
    const first = Array.from(raw)[0] ?? "";
    if (raw !== first) el('txt').value = first;
    return first;
  }

  function clampNum(v, lo, hi, fallback) {
    const n = Number(v);
    if (!Number.isFinite(n)) return fallback;
    return Math.max(lo, Math.min(hi, n));
  }

  function toHex(cp) {
    return "U+" + cp.toString(16).toUpperCase().padStart(4, "0");
  }

function applyBlockTheme(blockColor) {
  const wrap = el('outWrap');
  wrap.classList.toggle('blackBlocks', blockColor === 'black');
  wrap.classList.toggle('whiteBlocks', blockColor === 'white');
}

  function currentSettings() {
    const ch = enforceSingleCodePointInput();
    const font = el('font').value;
    const { w, h } = parseCell(el('cell').value);

    const thr = clampNum(el('thr').value, 0, 255, 96);
    el('thr').value = thr;

    const minPct = clampNum(el('minPct').value, 0, 100, 90);
    el('minPct').value = minPct;


    const bgCharRaw = (el('bgChar').value ?? "H");
    const bgChar = Array.from(bgCharRaw)[0] ?? "H"; // 1 code point
    el('bgChar').value = bgChar;

    const blockColor = el('blockColor').value === "white" ? "white" : "black";
    return { ch, font, w, h, thr, minPct, bgChar, blockColor };
  }

  // Render character into fixed WxH and return grayscale flat buffer (0..255), row-major.
  // 0 = black, 255 = white. Alpha blended over white background.
  function rasterizeTextToFlatGray(text, w, h, fontKind) {
    const cv = el('cv');
    cv.width = w;
    cv.height = h;

    const ctx = cv.getContext('2d', { willReadFrequently: true });

    // background white
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, w, h);

    // text in black
    ctx.fillStyle = "#000";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    const size = Math.floor(h * 0.78);
    ctx.font = `${size}px ${fontCSS(fontKind)}`;

    const yShift = Math.floor(h * 0.04);
    ctx.fillText(text, Math.floor(w / 2), Math.floor(h / 2) + yShift);

    const img = ctx.getImageData(0, 0, w, h).data;

    const gray = new Uint8Array(w * h);
    let k = 0;
    for (let i = 0; i < img.length; i += 4) {
      const r = img[i], g = img[i+1], b = img[i+2], a = img[i+3] / 255;
      const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
      const out = a * lum + (1 - a) * 255; // blend over white
      gray[k++] = Math.round(out);
    }
    return gray;
  }

  // Display-only: convert grayscale to block grid via thresholding.
function grayToBlockGrid(gray, w, h, threshold, bgChar) {
  const outRows = Math.floor(h / 2);
  const lines = [];

  for (let y = 0; y < outRows; y++) {
    let line = "";
    const topRow = (y * 2) * w;
    const botRow = (y * 2 + 1) * w;

    for (let x = 0; x < w; x++) {
      const topOn = (gray[topRow + x] < threshold) ? 1 : 0;
      const botOn = (gray[botRow + x] < threshold) ? 1 : 0;

      const idx = (topOn << 1) | botOn;   // 00,10,01,11 => 0,2,1,3
      const remap = [0, 2, 1, 3];
      const ch = BLOCKS[remap[idx]];      // ' ', '▀', '▄', '█'

      // Replace blank with background marker char
      line += (ch === ' ') ? bgChar : ch;
    }
    lines.push(line);
  }
  return lines;
}


  // Convolutional grayscale similarity (%).
  // For each target pixel, we look for best nearby candidate pixel:
  // weight 1.0 for same pixel; 0.5 for 8 neighbors.
  // grayscale similarity: 1 - |T-C|/255
  function convGraySimilarityPct(targetGray, candGray, w, h) {
    const offsets = [
      [ 0, 0, 1.0],
      [-1,-1, 0.5],[0,-1, 0.5],[1,-1, 0.5],
      [-1, 0, 0.5],         [1, 0, 0.5],
      [-1, 1, 0.5],[0, 1, 0.5],[1, 1, 0.5],
    ];

    const WH = w * h;
    let sum = 0;

    for (let y = 0; y < h; y++) {
      const base = y * w;
      for (let x = 0; x < w; x++) {
        const tIdx = base + x;
        const tVal = targetGray[tIdx];

        let best = 0;

        for (let k = 0; k < offsets.length; k++) {
          const dx = offsets[k][0], dy = offsets[k][1], wgt = offsets[k][2];
          const nx = x + dx, ny = y + dy;
          if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;

          const cVal = candGray[ny * w + nx];
          const sim = 1 - (Math.abs(tVal - cVal) / 255); // 0..1
          const score = wgt * sim;
          if (score > best) best = score;
        }

        sum += best; // 0..1
      }
    }

    return (sum / WH) * 100;
  }

  function setCompareUI(running) {
    el('compare').disabled = running;
    el('cancel').disabled = !running;
    el('txt').disabled = running;
    el('font').disabled = running;
    el('cell').disabled = running;
    el('thr').disabled = running;
    el('minPct').disabled = running;
  }

  function shouldSkipCodePoint(cp) {
    // skip surrogate range
    return (cp >= 0xD800 && cp <= 0xDFFF);
  }

  function describeChar(cp) {
    const ch = String.fromCodePoint(cp);
    const safe = (cp >= 0x20 && cp !== 0x7F) ? ch : "�";
    return `${toHex(cp)}  ${safe}`;
  }

  function render() 
  {
    const { ch, font, w, h, thr, bgChar, blockColor } = currentSettings();
    applyBlockTheme(blockColor);

    if (!ch) {
      el('meta').textContent = "Enter one character.";
      el('out').textContent = "";
      state.target = null;
      return;
    }

    const cp = ch.codePointAt(0);
    el('meta').innerHTML =
      `Code point: <span class="pill">${toHex(cp)}</span>` +
      ` <span class="pill">${w}×${h}</span>` +
      ` <span class="pill">display thr=${thr}</span>`;

    const gray = rasterizeTextToFlatGray(ch, w, h, font);
    el('out').textContent = grayToBlockGrid(gray, w, h, thr, bgChar).join("\n");

    state.target = { w, h, font, ch, gray };
  }

  async function copyGrid() {
    const text = el('out').textContent || "";
    el('copyStatus').textContent = "";
    if (!text) return;

    try {
      await navigator.clipboard.writeText(text + "\n");
      el('copyStatus').textContent = "Copied to clipboard.";
    } catch {
      try {
        const ta = document.createElement('textarea');
        ta.value = text + "\n";
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        el('copyStatus').textContent = "Copied to clipboard (fallback).";
      } catch {
        el('copyStatus').textContent = "Clipboard copy failed (browser blocked it).";
      }
    }
  }

  async function compareAll() {
    render();
    el('results').value = "";
    el('cmpStatus').textContent = "";

    const t = state.target;
    if (!t) {
      el('cmpStatus').textContent = "Nothing to compare (empty input).";
      return;
    }

    const { minPct } = currentSettings();
    const { w, h, font, gray: targetGray } = t;

    state.comparing = true;
    state.cancel = false;
    setCompareUI(true);

    let shown = 0;
    let cp = 0;

    const t0 = performance.now();
    const CHUNK = 200;

    el('cmpStatus').textContent = `Comparing… min ${minPct}%`;

    while (cp <= RANGE_MAX) {
      if (state.cancel) break;

      const end = Math.min(RANGE_MAX + 1, cp + CHUNK);
      for (; cp < end; cp++) {
        if (state.cancel) break;
        if (shouldSkipCodePoint(cp)) continue;

        const candidate = String.fromCodePoint(cp);
        const candGray = rasterizeTextToFlatGray(candidate, w, h, font);
        const score = convGraySimilarityPct(targetGray, candGray, w, h);

        if (score >= minPct) {
          shown++;
          el('results').value += `${score.toFixed(1).padStart(5, " ")}%  ${describeChar(cp)}\n`;
        }
      }

      const pctDone = Math.round((cp / (RANGE_MAX + 1)) * 1000) / 10;
      const elapsed = Math.round(performance.now() - t0);
      el('cmpStatus').textContent =
        `Comparing… ${toHex(cp)} / ${toHex(RANGE_MAX)} (${pctDone}%). ` +
        `Shown: ${shown} (≥ ${minPct}%). Elapsed: ${elapsed} ms.`;

      await new Promise(r => setTimeout(r, 0));
    }

    const elapsed = Math.round(performance.now() - t0);

    if (!state.cancel) {
      el('cmpStatus').textContent =
        `Done. Scanned U+0000..U+1869F. Shown: ${shown} (≥ ${minPct}%). Elapsed: ${elapsed} ms.`;
      if (shown === 0) el('results').value = "(No matches at/above threshold.)\n";
    } else {
      el('cmpStatus').textContent =
        `Cancelled at ${toHex(cp)}. Shown: ${shown}. Elapsed: ${elapsed} ms.`;
      if (!el('results').value.trim()) el('results').value = "(Cancelled — no matches recorded yet.)\n";
    }

    state.comparing = false;
    setCompareUI(false);
  }

  // UI wiring
  el('txt').addEventListener('input', () => { enforceSingleCodePointInput(); render(); });
  el('font').addEventListener('change', render);
  el('cell').addEventListener('change', render);
  el('thr').addEventListener('change', render);
  el('minPct').addEventListener('change', () => {
    el('minPct').value = clampNum(el('minPct').value, 0, 100, 90);
  });

  el('copy').addEventListener('click', copyGrid);
  el('compare').addEventListener('click', compareAll);
  el('cancel').addEventListener('click', () => { state.cancel = true; });

  el('bgChar').addEventListener('input', render);
  el('blockColor').addEventListener('change', render);


  // initial render
  enforceSingleCodePointInput();
  render();
})();
</script>
</body>
</html>
