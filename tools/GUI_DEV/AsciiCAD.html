<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AsciiCAD</title>
 <link rel="stylesheet" href="AsciiCAD.css">
  <script src="AsciiCAD_helpers.js"></script>
 <script src="AsciiCAD_catalog.js"></script>
</head>
<body>
  <div class="app">
    <aside id="sidebar" class="sidebar">
      <div class="sb-top">
        <button id="toggleSidebar" class="btn" title="Collapse / Expand" aria-label="Toggle sidebar">◀</button>
        <div id="sbTitle" class="sb-title"><big>AsciiCAD v0.4</big><br><small>Author: Freddy Vandriessche</small></div>
      </div>
      <div class="sb-content">
        <div class="card">
          <h3>Canvas</h3>
          <div id="cellsLine">Cells: —</div>
          <div id="zoomLine">Zoom: 100%</div>
          <div class="tiny muted" id="coordLine">Cell: —</div>
        </div>

        <div class="card">
          <h3>Mode</h3>
          <div class="row">
            <button id="modeFreeform" class="btn primary">Freeform</button>
            <button id="modeSelect" class="btn">Select &amp; Move</button>
            <button id="modeLine" class="btn">Line</button>
          </div>
          <div id="modeHint" class="tiny muted" style="margin-top:8px;">Drag to draw (cell-by-cell).</div>
        </div>

        <div class="card">
          <h3>Draw</h3>
          <div class="tiny muted">Pick a char or catalog item, then draw / place.</div>
          <div class="row" style="margin-top:10px;">
            <button id="pickChar" class="btn">Char</button>
            <button id="openCatalog" class="btn">Catalog</button>
            <button id="eraser" class="btn">Space</button>
          </div>
          <div class="tiny muted" id="currentOp" style="margin-top:10px;">Current: place '+'</div>
        </div>

        <div class="card">
          <h3>Load &amp; Save</h3>
          <div class="row" style="margin-top:10px;">
            <button id="undoBtn" class="btn" disabled>Undo</button>
            <button id="redoBtn" class="btn" disabled>Redo</button>
            <button id="saveBtn" class="btn">Save</button>
            <button id="loadBtn" class="btn">Load</button>
            <button id="pasteBtn" class="btn">Paste</button>
            <button id="clearBtn" class="btn">Clear</button>
            <input id="fileInput" type="file" accept="text/plain" style="display:none" />
          </div>
          <div class="tiny muted" id="historyLine" style="margin-top:10px;">Undo stack: 0 · Redo stack: 0</div>
          <div class="tiny muted" id="pasteLine" style="margin-top:6px; display:none;">Paste: move preview with mouse, click to place.</div>
        </div>

        <div class="card">
          <div class="tiny muted">Wheel = zoom • Hold mouse button while wheel = pan • Middle-drag = pan • R = rotate</div>
        </div>
      </div>
    </aside>

    <main class="main">
      <div id="container" class="container">
        <div id="stage" class="stage">
          <canvas id="canvas" tabindex="0"></canvas>
        </div>
      </div>
    </main>
  </div>

  <!-- Char Picker -->
  <div id="picker" class="modal" aria-hidden="true">
    <div class="backdrop" id="pickerBackdrop"></div>
    <div class="panel" role="dialog" aria-modal="true" aria-label="Pick a character">
      <div class="panel-top">
        <div style="font-weight:500;">Pick a character</div>
        <button id="pickerClose" class="btn">Close</button>
      </div>
      <div id="tabs" class="tabs"></div>
      <div id="charGrid" class="char-grid"></div>
      <div class="tiny muted" style="margin-top:10px;">Selected: <span id="selectedChar" style="font-weight:500;">+</span></div>
    </div>
  </div>

  <!-- Catalog -->
  <div id="catalogModal" class="modal" aria-hidden="true">
    <div class="backdrop" id="catalogBackdrop"></div>
    <div class="panel" role="dialog" aria-modal="true" aria-label="Catalog">
      <div class="panel-top">
        <div style="font-weight:500;">Catalog</div>
        <button id="catalogClose" class="btn">Close</button>
      </div>
      <div id="catalogTabs" class="tabs"></div>
      <div id="catalogGrid" class="catalog-grid"></div>
      <div class="tiny muted" style="margin-top:10px;">Pick an item → move preview → click to place (clipped).</div>
    </div>
  </div>

  <textarea id="pasteSink" aria-hidden="true"></textarea>

  <script>
  'use strict';

//    ███████  ██████ ██████  ██ ██████  ████████ 
//    ██      ██      ██   ██ ██ ██   ██    ██    
//    ███████ ██      ██████  ██ ██████     ██    
//         ██ ██      ██   ██ ██ ██         ██    
//    ███████  ██████ ██   ██ ██ ██         ██   

const COLS = 256;
const ROWS = 128;

const GRID_BG = '#FFFFFF';
const GRID_LINE = '#EEEEEE';

const MIN_SCALE = 0.5;
const MAX_SCALE = 10;

const baseCellW = 10;
const baseCellH = 20;

// View state
let sidebarOpen = true;
let scale = 1;
let panX = 0;
let panY = 0;
let panDrag = null; // {x,y,panX0,panY0}

// UI refs
const sidebar = document.getElementById('sidebar');
const toggleSidebar = document.getElementById('toggleSidebar');
const sbTitle = document.getElementById('sbTitle');
const cellsLine = document.getElementById('cellsLine');
const zoomLine = document.getElementById('zoomLine');
const coordLine = document.getElementById('coordLine');
const modeFreeform = document.getElementById('modeFreeform');
const modeSelect = document.getElementById('modeSelect');
const modeLine = document.getElementById('modeLine');
const modeHint = document.getElementById('modeHint');
const pickCharBtn = document.getElementById('pickChar');
const openCatalogBtn = document.getElementById('openCatalog');
const eraserBtn = document.getElementById('eraser');
const currentOpLine = document.getElementById('currentOp');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const saveBtn = document.getElementById('saveBtn');
const loadBtn = document.getElementById('loadBtn');
const pasteBtn = document.getElementById('pasteBtn');
const clearBtn = document.getElementById('clearBtn');
const fileInput = document.getElementById('fileInput');
const historyLine = document.getElementById('historyLine');
const pasteLine = document.getElementById('pasteLine');

const container = document.getElementById('container');
const stage = document.getElementById('stage');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const picker = document.getElementById('picker');
const pickerBackdrop = document.getElementById('pickerBackdrop');
const pickerClose = document.getElementById('pickerClose');
const tabsEl = document.getElementById('tabs');
const charGrid = document.getElementById('charGrid');
const selectedCharEl = document.getElementById('selectedChar');

const catalogModal = document.getElementById('catalogModal');
const catalogBackdrop = document.getElementById('catalogBackdrop');
const catalogClose = document.getElementById('catalogClose');
const catalogTabsEl = document.getElementById('catalogTabs');
const catalogGridEl = document.getElementById('catalogGrid');

const pasteSink = document.getElementById('pasteSink');

// Data model
const ascii = Array.from({ length: ROWS }, () => Array.from({ length: COLS }, () => ' '));

// Tool state
let tool = 'freeform';
let op = { type: 'place', ch: '+' };
let hoverCell = null;
let stageSize = { w: 1, h: 1 };

let isDrawing = false;
let lastCellKey = null;
let currentStroke = [];
const undoStack = [];
const redoStack = [];

let selection = null; // {r0,r1,c0,c1}
let selectDrag = null; // {start,current}
let moveDrag = null; // {startCell, offset, baseRect, snapshot}

let pasteDrag = null; // {lines,w,h,anchor,transparentSpaces}

let lineDrag = null;  // { start:{r,c}, cur:{r,c} }

// Picker tabs
let pickerTab = 'Box';
let catalogTab = 'All';

//    ██   ██ ███████ ██      ██████  ███████ ██████  ███████ 
//    ██   ██ ██      ██      ██   ██ ██      ██   ██ ██      
//    ███████ █████   ██      ██████  █████   ██████  ███████ 
//    ██   ██ ██      ██      ██      ██      ██   ██      ██ 
//    ██   ██ ███████ ███████ ██      ███████ ██   ██ ███████ 

function cornerCharVH(r0, c0, r1, c1) {
  const goingDown = r1 > r0;
  const goingRight = c1 > c0;

  // We go vertical to r1 first, then horizontal to c1.
  // Corner is at (r1, c0): it must connect vertical + horizontal.
  if (goingDown && goingRight) return "└"; // up + right
  if (goingDown && !goingRight) return "┘"; // up + left
  if (!goingDown && goingRight) return "┌"; // down + right
  return "┐"; // down + left
}

function buildVHPath(start, end) {
  const r0 = start.r, c0 = start.c;
  const r1 = end.r, c1 = end.c;

  const out = [];

  // same cell: nothing (or return a dot if you prefer)
  if (r0 === r1 && c0 === c1) return out;

  // 1) vertical segment at column c0 from r0 -> r1 (inclusive)
  if (r0 !== r1) {
    const stepR = r1 > r0 ? 1 : -1;
    for (let r = r0; r !== r1; r += stepR) {
      out.push({ r, c: c0, ch: "│" });
    }
    out.push({ r: r1, c: c0, ch: "│" });
  }

  // 2) corner at (r1, c0) if there is also a horizontal leg
  if (r0 !== r1 && c0 !== c1) {
    out[out.length - 1].ch = cornerCharVH(r0, c0, r1, c1); // replace last vertical cell with corner
  }

  // 3) horizontal segment at row r1 from c0 -> c1 (inclusive)
  if (c0 !== c1) {
    const stepC = c1 > c0 ? 1 : -1;

    // start after the corner if we had a vertical leg, otherwise start at c0
    let cStart = c0;
    if (r0 !== r1) cStart = c0 + stepC;

    for (let c = cStart; c !== c1; c += stepC) {
      out.push({ r: r1, c, ch: "─" });
    }
    out.push({ r: r1, c: c1, ch: "─" });
  }

  return out;
}

function beginLine(cell) {
  if (!cell) return;
  // hide selection box when starting a line tool action
  selection = null; selectDrag = null; moveDrag = null;
  lineDrag = { start: { r: cell.r, c: cell.c }, cur: { r: cell.r, c: cell.c } };
  draw();
}

function moveLine(cell) {
  if (!lineDrag) return;
  if (!cell) return;
  if (cell.r === lineDrag.cur.r && cell.c === lineDrag.cur.c) return;
  lineDrag.cur = { r: cell.r, c: cell.c };
  draw();
}

function endLine() {
  if (!lineDrag) return;

  const path = buildVHPath(lineDrag.start, lineDrag.cur);
  const stroke = [];

  for (const p of path) {
    if (p.r < 0 || p.r >= ROWS || p.c < 0 || p.c >= COLS) continue;

    const prev = ascii[p.r][p.c];
    const next = p.ch;

    if (prev !== next) {
      stroke.push({ r: p.r, c: p.c, prev, next });
      drawCharAtCell(p.r, p.c, next); // ✅ commit writes to ascii
    }
  }

  lineDrag = null;
  pushStrokeIfNonEmpty(stroke);
  draw();
}

function cancelLine() {
  lineDrag = null;
  draw();
}


function cornerChar(r0, c0, r1, c1) {
  const goingDown = r1 > r0;
  const goingRight = c1 > c0;
  if (goingDown && goingRight) return "└";
  if (goingDown && !goingRight) return "┘";
  if (!goingDown && goingRight) return "┌";
  return "┐";
}

function setToolLine() {
  tool = 'line';
  selection = null; selectDrag = null; moveDrag = null;
  cancelPaste();
  cancelLine();
  updateUI();
  draw();
}

function buildVHPath(start, end) {
  const r0 = start.r, c0 = start.c;
  const r1 = end.r, c1 = end.c;

  const out = [];

  // 1) vertical segment from r0 -> r1 at column c0
  if (r0 !== r1) {
    const step = r1 > r0 ? 1 : -1;
    for (let r = r0; r !== r1; r += step) {
      out.push({ r, c: c0, ch: "│" });
    }
  }

  // Corner cell at (r1, c0)
  if (c0 !== c1 && r0 !== r1) {
    out.push({ r: r1, c: c0, ch: cornerChar(r0, c0, r1, c1) });
  } else if (r0 !== r1) {
    // If only vertical, include the last cell as vertical
    out.push({ r: r1, c: c0, ch: "│" });
  }

  // 2) horizontal segment from c0 -> c1 at row r1
  if (c0 !== c1) {
    const step = c1 > c0 ? 1 : -1;
    // start from c0 if no corner was placed (pure horizontal),
    // otherwise start after the corner to avoid overwriting it.
    const startC = (r0 !== r1) ? (c0 + step) : c0;
    for (let c = startC; c !== c1; c += step) {
      out.push({ r: r1, c, ch: "─" });
    }
    out.push({ r: r1, c: c1, ch: "─" }); // include end cell
  }

  // If start==end: draw nothing (or a dot if you prefer)
  return out;
}


function canvasPointToCell(clientX, clientY) {
const rect = canvas.getBoundingClientRect();
const px = ((clientX - rect.left) * stageSize.w) / rect.width;
const py = ((clientY - rect.top) * stageSize.h) / rect.height;
const cx = stageSize.w / 2;
const cy = stageSize.h / 2;
const ux = (px - cx) / scale + cx - panX;
const uy = (py - cy) / scale + cy - panY;
const { cw, ch } = getCellSize();
const c = Math.floor(ux / cw);
const r = Math.floor(uy / ch);
if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return null;
return { r, c };
}

function updateUI() {
cellsLine.textContent = 'Cells: ' + COLS + ' x ' + ROWS;
zoomLine.textContent = 'Zoom: ' + Math.round(scale * 100) + '%';
coordLine.textContent = hoverCell ? ('Cell: Ln ' + (hoverCell.r+1) + ', Col ' + (hoverCell.c+1)) : 'Cell: —';

pasteLine.style.display = pasteDrag ? 'block' : 'none';

if (tool === 'freeform') {
  modeFreeform.classList.add('primary');
  modeSelect.classList.remove('primary');
  modeLine.classList.remove('primary');
  modeHint.textContent = pasteDrag
    ? 'Pasting: move preview with mouse, click to place.'
    : 'Drag to draw (cell-by-cell).';
}
else if (tool === 'line') {
  modeLine.classList.add('primary');
  modeFreeform.classList.remove('primary');
  modeSelect.classList.remove('primary');
  modeHint.textContent = pasteDrag
    ? 'Pasting: move preview with mouse, click to place.'
    : 'Drag: press to set start, move to preview, release to place line.';
}
else if (tool === 'select') {
  modeSelect.classList.add('primary');
  modeFreeform.classList.remove('primary');
  modeLine.classList.remove('primary');
  modeHint.textContent = pasteDrag
    ? 'Pasting: move preview with mouse, click to place.'
    : 'Drag to select. Drag inside selection to move.';
}

currentOpLine.textContent = op.type === 'place' ? ('Current: place \' ' + op.ch + ' \'' ) : 'Current: space';
selectedCharEl.textContent = op.type === 'place' ? op.ch : '(space)';

undoBtn.disabled = undoStack.length === 0;
redoBtn.disabled = redoStack.length === 0;
historyLine.textContent = 'Undo stack: ' + undoStack.length + ' · Redo stack: ' + redoStack.length;

toggleSidebar.textContent = sidebarOpen ? '◀' : '▶';
sbTitle.style.display = sidebarOpen ? 'block' : 'none';
}


function isDoubleWidthChar(ch) {
if (!ch) return false;
const cp = ch.codePointAt(0);

// Quick ASCII / Latin
if (cp <= 0x1FFF) return false;

// Common wide ranges (wcwidth-style; not exhaustive but good enough)
return (
    (cp >= 0x1100 && cp <= 0x115F) || // Hangul Jamo init.
    cp === 0x2329 || cp === 0x232A ||
    (cp >= 0x2E80 && cp <= 0xA4CF) || // CJK, Yi, radicals...
    (cp >= 0xAC00 && cp <= 0xD7A3) || // Hangul syllables
    (cp >= 0xF900 && cp <= 0xFAFF) || // CJK compatibility ideographs
    (cp >= 0xFE10 && cp <= 0xFE19) ||
    (cp >= 0xFE30 && cp <= 0xFE6F) ||
    (cp >= 0xFF00 && cp <= 0xFF60) || // Fullwidth forms
    (cp >= 0xFFE0 && cp <= 0xFFE6) ||
    (cp >= 0x1F300 && cp <= 0x1FAFF) || // emoji blocks (often wide)
    (cp >= 0x20000 && cp <= 0x3FFFD) || // CJK ext
    cp === 0x2B24 // ⬤ specifically
);
}

function expandWideCharsForGrid(text) {
const outLines = [];
const lines = toLines(text); // your normalizeNewlines + split("\n")
for (const line of lines) {
    let out = "";
    for (const ch of line) {           // code-point safe
    out += ch;
    if (isDoubleWidthChar(ch)) out += " ";  // pad one cell
    }
    outLines.push(out);
}
return outLines.join("\n");
}

function collapseAfterWideCharsForSave(text)
{
const lines = toLines(text);
const out = [];

for (const line of lines) {
    // Work at code-point level but treat output as "cells"
    const cells = Array.from(line); // code points
    const filtered = [];

    for (let i = 0; i < cells.length; i++) {
    const ch = cells[i];
    filtered.push(ch);

    if (isDoubleWidthChar(ch)) {
        // Remove the following cell by skipping it
        i += 1;
    }
    }
    out.push(filtered.join(""));
}

return out.join("\n");
}

function downloadText(text, filename) {
const name = filename || 'ascii-drawing.txt';
const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = name;
a.rel = 'noopener';
a.style.display = 'none';
document.body.appendChild(a);
try { a.click(); } finally { setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0); }
}

function pushStrokeIfNonEmpty(stroke) {
if (!stroke || stroke.length === 0) return;
undoStack.push(stroke);
redoStack.length = 0;
updateUI();
}

function doUndo() {
const stroke = undoStack.pop();
if (!stroke) return;
for (let i = stroke.length - 1; i >= 0; i--) ascii[stroke[i].r][stroke[i].c] = stroke[i].prev;
redoStack.push(stroke);
updateUI();
draw();
}

function doRedo() {
const stroke = redoStack.pop();
if (!stroke) return;
for (let i = 0; i < stroke.length; i++) ascii[stroke[i].r][stroke[i].c] = stroke[i].next;
undoStack.push(stroke);
updateUI();
draw();
}

function snapshotRect(rect) {
const m = new Map();
for (let r = rect.r0; r <= rect.r1; r++) for (let c = rect.c0; c <= rect.c1; c++) m.set(r + ',' + c, ascii[r][c]);
return m;
}

// Paste (preview + commit)
function startPasteWithText(text) 
{
const raw = normalizeNewlines(text).split('\n');
while (raw.length > 0 && raw[raw.length - 1] === '') raw.pop();
if (raw.length === 0) { pasteDrag = null; updateUI(); draw(); return; }

let w = 0;
for (const ln of raw) w = Math.max(w, ln.length);

const maxH = Math.min(raw.length, ROWS);
const maxW = Math.min(w, COLS);
const lines = raw.slice(0, maxH).map(ln => ln.slice(0, maxW));

pasteDrag = {
    lines,
    h: lines.length,
    w: maxW,
    item_data: pasteDrag==null ? null : pasteDrag.item_data, // carry over item data if any 
    anchor: hoverCell ? { r: hoverCell.r, c: hoverCell.c } : { r: Math.floor(ROWS/2), c: Math.floor(COLS/2) },
    transparentSpaces: true,
};

// Paste mode implies Select tool (so cursor behavior matches your workflow)
tool = 'select';
// Clear selection overlay while pasting
selection = null;
selectDrag = null;
moveDrag = null;

updateUI();
draw();
}

function commitLine() {
  if (!lineDrag) return;
  const path = buildVHPath(lineDrag.start, lineDrag.cur);

  const stroke = [];
  for (const p of path) {
    if (p.r < 0 || p.r >= ROWS || p.c < 0 || p.c >= COLS) continue;

    const prev = ascii[p.r][p.c];
    const next = p.ch;

    if (prev !== next) {
      stroke.push({ r: p.r, c: p.c, prev, next });
      ascii[p.r][p.c] = next;
    }
  }

  lineDrag = null;
  pushStrokeIfNonEmpty(stroke);
  draw();
}

function commitPasteAt(cell) {
if (!pasteDrag || !cell) return;
const a = { r: cell.r, c: cell.c };
const stroke = [];

for (let rr = 0; rr < pasteDrag.h; rr++) {
    const line = pasteDrag.lines[rr] || '';
    for (let cc = 0; cc < pasteDrag.w; cc++) {
    const chx = line[cc] || ' ';
    if (pasteDrag.transparentSpaces && chx === ' ') continue;
    const tr = a.r + rr;
    const tc = a.c + cc;
    if (tr < 0 || tr >= ROWS || tc < 0 || tc >= COLS) continue; // clip
    const prev = ascii[tr][tc];
    const next = chx;
    if (prev === next) continue;
    stroke.push({ r: tr, c: tc, prev, next });
    ascii[tr][tc] = next;
    }
}

pasteDrag = null;
pushStrokeIfNonEmpty(stroke);
updateUI();
draw();
}

function cancelPaste() {
if (!pasteDrag) return;
pasteDrag = null;
updateUI();
draw();
}

// Freeform drawing
function applyOpAtCell(cell) {
const prev = ascii[cell.r][cell.c];
const next = (op.type === 'place') ? op.ch : ' ';
if (prev === next) return;
currentStroke.push({ r: cell.r, c: cell.c, prev, next });
ascii[cell.r][cell.c] = next;
}

function beginFreeform(cell) {
isDrawing = true;
lastCellKey = null;
currentStroke = [];
if (!cell) return;
lastCellKey = cell.r + ',' + cell.c;
applyOpAtCell(cell);
draw();
}

function moveFreeform(cell) {
if (!isDrawing || !cell) return;
const key = cell.r + ',' + cell.c;
if (key === lastCellKey) return;
lastCellKey = key;
applyOpAtCell(cell);
draw();
}

function endFreeform() {
if (!isDrawing) return;
isDrawing = false;
const stroke = currentStroke;
currentStroke = [];
lastCellKey = null;
pushStrokeIfNonEmpty(stroke);
}

// Select & move
function applyMove(baseRect, dr, dc, snapMap) {
if (dr === 0 && dc === 0) return;
const stroke = [];

// Clear base rect
for (let r = baseRect.r0; r <= baseRect.r1; r++) {
    for (let c = baseRect.c0; c <= baseRect.c1; c++) {
    const prev = ascii[r][c];
    if (prev !== ' ') {
        stroke.push({ r, c, prev, next: ' ' });
        ascii[r][c] = ' ';
    }
    }
}

// Paste moved snapshot (clip to grid)
for (let r = baseRect.r0; r <= baseRect.r1; r++) {
    for (let c = baseRect.c0; c <= baseRect.c1; c++) {
    const chx = snapMap.get(r + ',' + c) || ' ';
    const rr = r + dr;
    const cc = c + dc;
    if (rr < 0 || rr >= ROWS || cc < 0 || cc >= COLS) continue;
    const prev = ascii[rr][cc];
    const next = chx;
    if (prev !== next) {
        stroke.push({ r: rr, c: cc, prev, next });
        ascii[rr][cc] = next;
    }
    }
}

pushStrokeIfNonEmpty(stroke);
}

function beginSelect(cell) {
if (!cell) return;

if (selection && cell.r >= selection.r0 && cell.r <= selection.r1 && cell.c >= selection.c0 && cell.c <= selection.c1) {
    moveDrag = { startCell: cell, offset: { dr: 0, dc: 0 }, baseRect: selection, snapshot: snapshotRect(selection) };
    draw();
    return;
}

selection = null;
moveDrag = null;
selectDrag = { start: cell, current: cell };
draw();
}

function moveSelect(cell) {
if (!cell) return;
if (moveDrag) {
    const dr = cell.r - moveDrag.startCell.r;
    const dc = cell.c - moveDrag.startCell.c;
    if (dr === moveDrag.offset.dr && dc === moveDrag.offset.dc) return;
    moveDrag.offset = { dr, dc };
    draw();
    return;
}
if (selectDrag) {
    selectDrag.current = cell;
    draw();
}
}

function endSelect() {
// Keep selection after selecting; clear after move commit.
if (moveDrag) {
    const base = moveDrag.baseRect;
    const snapMap = moveDrag.snapshot;
    const { dr, dc } = moveDrag.offset;
    applyMove(base, dr, dc, snapMap);
    moveDrag = null;
    selectDrag = null;
    selection = null; // disappear after move mouseup
    draw();
    return;
}
if (selectDrag) {
    selection = normRect(selectDrag.start, selectDrag.current);
    selectDrag = null;
    draw();
}
}

// Modals
function openPicker() {
picker.classList.add('open');
picker.setAttribute('aria-hidden', 'false');
renderTabs();
renderCharGrid();
updateUI();
}

function closePicker() {
picker.classList.remove('open');
picker.setAttribute('aria-hidden', 'true');
updateUI();
}

function renderTabs() {
tabsEl.innerHTML = '';
for (const tab of Object.keys(PICKER_TABS)) {
    const b = document.createElement('button');
    b.className = 'btn' + (tab === pickerTab ? ' primary' : '');
    b.textContent = tab;
    b.addEventListener('click', () => { pickerTab = tab; renderTabs(); renderCharGrid(); });
    tabsEl.appendChild(b);
}
}

function renderCharGrid() {
charGrid.innerHTML = '';
const arr = PICKER_TABS[pickerTab] || [];
for (const ch of arr) {
    const b = document.createElement('button');
    b.className = 'char';
    b.textContent = ch;
    b.title = "Select '" + ch + "' 0x" + ch.codePointAt(0).toString(16).toUpperCase();
    b.addEventListener('click', () => { op = { type: 'place', ch }; closePicker(); updateUI(); });
    charGrid.appendChild(b);
}
}

function renderCharAtCell(ctx, r, c, ch) {
  // Use the SAME positioning math you already use when drawing ascii[][] in draw().
  // If your draw() loops cells and does ctx.fillText(...) at some (x,y),
  // copy that exact x/y logic here.
  const x = c * baseCellW + baseCellW / 2;
  const y = r * baseCellH + baseCellH / 2;

  ctx.fillText(ch, x, y);
}


function openCatalog() {
catalogModal.classList.add('open');
catalogModal.setAttribute('aria-hidden', 'false');
renderCatalogTabs();
renderCatalogGrid();
updateUI();
}

function closeCatalog() {
catalogModal.classList.remove('open');
catalogModal.setAttribute('aria-hidden', 'true');
updateUI();
}

function renderCatalogTabs() {
catalogTabsEl.innerHTML = '';
const types = ['All', ...catalogTypes()];
for (const t of types) {
    const b = document.createElement('button');
    b.className = 'btn' + (t === catalogTab ? ' primary' : '');
    b.textContent = t;
    b.addEventListener('click', () => { catalogTab = t; renderCatalogTabs(); renderCatalogGrid(); });
    catalogTabsEl.appendChild(b);
}
}

function renderCatalogGrid() {
catalogGridEl.innerHTML = '';
const items = catalogItemsForTab(catalogTab);
for (const it of items) {
    const card = document.createElement('div');
    card.className = 'cat-item';
    card.title = it.name + (it.MFR ? (' · ' + it.MFR) : '');

    const img = document.createElement('img');
    img.className = 'cat-thumb';
    img.alt = it.name;
    img.src = it.image_data;

    const cap = document.createElement('div');
    cap.className = 'cat-name';
    cap.textContent = it.name;

    card.appendChild(img);
    card.appendChild(cap);

    card.addEventListener('click', () => {
    closeCatalog();

    // FVD TODO
        if(pasteDrag==null) pasteDrag = {item_data:{}};
        pasteDrag.item_data.rotation = 0;                           // default rotation
        pasteDrag.item_data.uid = it.name+'_'+it.type+'_'+it.MFR;   // unique id for this catalog item
        const text_data = it.text_data[ pasteDrag.item_data.rotation ];

    startPasteWithText(expandWideCharsForGrid(text_data) || '');
    canvas.focus();
    });

    catalogGridEl.appendChild(card);
}
}

// Drawing
function drawPastePreview(cw, ch, snap) {
if (!pasteDrag || !pasteDrag.anchor) return;
const a = pasteDrag.anchor;

//console.log('drawPastePreview at', a, 'size', pasteDrag.w, 'x', pasteDrag.h, 'r', pasteDrag.r);

// Preview fill (clipped to visible grid)
const pxW = Math.max(0, Math.min(pasteDrag.w, COLS - a.c)) * cw;
const pxH = Math.max(0, Math.min(pasteDrag.h, ROWS - a.r)) * ch;
if (pxW > 0 && pxH > 0) {
    ctx.save();
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = 'rgba(16,185,129,0.10)';
    ctx.fillRect(a.c * cw, a.r * ch, pxW, pxH);
    ctx.restore();
}

ctx.save();
ctx.globalAlpha = 0.9;
for (let rr = 0; rr < pasteDrag.h; rr++) {
    const line = pasteDrag.lines[rr] || '';
    for (let cc = 0; cc < pasteDrag.w; cc++) {
    const chx = line[cc] || ' ';
    if (pasteDrag.transparentSpaces && chx === ' ') continue;
    const tr = a.r + rr;
    const tc = a.c + cc;
    if (tr < 0 || tr >= ROWS || tc < 0 || tc >= COLS) continue;
    ctx.fillText(chx, snap(tc * cw + cw/2), snap(tr * ch + ch/2));
    }
}
ctx.restore();

ctx.save();
ctx.lineWidth = 2 / scale;
ctx.setLineDash([6 / scale, 4 / scale]);
ctx.strokeStyle = 'rgba(16,185,129,0.95)';
ctx.strokeRect(a.c * cw, a.r * ch, pasteDrag.w * cw, pasteDrag.h * ch);
ctx.restore();
}

function drawCharPreviewAtCell(ctx, r, c, ch) {
  // Compute the screen position the same way you draw normal characters.
  // Example placeholders:
  const x = c * baseCellW + baseCellW / 2;
  const y = r * baseCellH + baseCellH / 2;

  // Use your existing font/baseline setup (whatever you use for normal draw).
  ctx.fillText(ch, x, y);
}



//    ███    ███  █████  ██ ███    ██ 
//    ████  ████ ██   ██ ██ ████   ██ 
//    ██ ████ ██ ███████ ██ ██ ██  ██ 
//    ██  ██  ██ ██   ██ ██ ██  ██ ██ 
//    ██      ██ ██   ██ ██ ██   ████ 

console.log("AsciiCAD log test");
console.warn("AsciiCAD warn test");
console.error("AsciiCAD error test");

function draw() 
{
    console.log('draw() called');
    const dpr = window.devicePixelRatio || 1;
    const wCss = stageSize.w;
    const hCss = stageSize.h;

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    ctx.fillStyle = GRID_BG;
    ctx.fillRect(0,0,wCss,hCss);

    const cx = wCss/2, cy = hCss/2;
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);
    ctx.translate(-cx + panX, -cy + panY);

    const { snap, snapLine } = getSnapFns(dpr, scale);

    var { cw, ch } = { cw: baseCellW, ch: baseCellH };

    // Visible bounds in WORLD coordinates (undo pan/zoom around center)
    const left   = (0 - cx) / scale + cx - panX;
    const right  = (wCss - cx) / scale + cx - panX;
    const top    = (0 - cy) / scale + cy - panY;
    const bottom = (hCss - cy) / scale + cy - panY;

    // Convert bounds -> grid indices (clamped)
    const c0 = Math.max(0, Math.floor(left / cw));
    const c1 = Math.min(COLS, Math.ceil(right / cw));
    const r0 = Math.max(0, Math.floor(top / ch));
    const r1 = Math.min(ROWS, Math.ceil(bottom / ch));

    ctx.beginPath();
    ctx.strokeStyle = GRID_LINE;
    ctx.lineWidth = 1 / scale;

    // vertical lines
    for (let c = c0; c <= c1; c++) {
    const x = snapLine(c * cw);
    ctx.moveTo(x, snapLine(r0 * ch));
    ctx.lineTo(x, snapLine(r1 * ch));
    }

    // horizontal lines
    for (let r = r0; r <= r1; r++) {
    const y = snapLine(r * ch);
    ctx.moveTo(snapLine(c0 * cw), y);
    ctx.lineTo(snapLine(c1 * cw), y);
    }

    ctx.stroke();

    // Font sized to cell
    ctx.fillStyle = '#000';

    const cwr = 0.62;   // 0.62

    const maxByHeight = ch * 0.98;
    const maxByWidth = (cw / cwr) * 0.98;
    const fontPx = Math.max(4, Math.floor(Math.min(maxByHeight, maxByWidth)));
    ctx.font = fontPx + 'px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Move preview
    if (moveDrag) {
        const b = moveDrag.baseRect;
        const o = moveDrag.offset;
        const snapMap = moveDrag.snapshot;
        ctx.save();
        ctx.globalAlpha = 0.9;
        for (let r = b.r0; r <= b.r1; r++) {
        for (let c = b.c0; c <= b.c1; c++) {
            const chx = snapMap.get(r + ',' + c) || ' ';
            if (chx === ' ') continue;
            const rr = r + o.dr;
            const cc = c + o.dc;
            if (rr < 0 || rr >= ROWS || cc < 0 || cc >= COLS) continue;
            ctx.fillText(chx, snap(cc * cw + cw/2), snap(rr * ch + ch/2));
        }
        }
        ctx.restore();
    }

    // Draw all chars (skip base rect while moving)
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
        const chx = ascii[r][c];
        if (chx === ' ') continue;
        if (moveDrag) {
            const b = moveDrag.baseRect;
            if (r >= b.r0 && r <= b.r1 && c >= b.c0 && c <= b.c1) continue;
        }
        ctx.fillText(chx, snap(c * cw + cw/2), snap(r * ch + ch/2));
        }
    }

    // Selection overlay (stays after select; cleared after move mouseup)
    if (selection) {
        const x0 = selection.c0 * cw;
        const y0 = selection.r0 * ch;
        const w = (selection.c1 - selection.c0 + 1) * cw;
        const h = (selection.r1 - selection.r0 + 1) * ch;
        ctx.save();
        ctx.lineWidth = 2 / scale;
        ctx.strokeStyle = 'rgba(59,130,246,0.9)';
        ctx.fillStyle = 'rgba(59,130,246,0.12)';
        ctx.fillRect(x0, y0, w, h);
        ctx.strokeRect(x0, y0, w, h);
        ctx.restore();
    }

    // Drag-select marquee
    if (selectDrag) {
        const rr = normRect(selectDrag.start, selectDrag.current);
        const x0 = rr.c0 * cw;
        const y0 = rr.r0 * ch;
        const w = (rr.c1 - rr.c0 + 1) * cw;
        const h = (rr.r1 - rr.r0 + 1) * ch;
        ctx.save();
        ctx.lineWidth = 2 / scale;
        ctx.setLineDash([6/scale, 4/scale]);
        ctx.strokeStyle = 'rgba(16,185,129,0.95)';
        ctx.strokeRect(x0, y0, w, h);
        ctx.restore();
    }

    if (pasteDrag) drawPastePreview(cw, ch, snap);

    drawLinePreview();

    // Line preview overlay
    if (lineDrag) {
    const old = ctx.fillStyle;
    ctx.fillStyle = "rgba(59,130,246,0.9)";

    const path = buildVHPath(lineDrag.start, lineDrag.cur);
    for (const p of path) {
        if (p.r < 0 || p.r >= ROWS || p.c < 0 || p.c >= COLS) continue;
        renderCharAtCell(ctx, p.r, p.c, p.ch);   // ✅ canvas-only
    }

    ctx.fillStyle = old;
    }
}

function drawLinePreview() {
  if (!lineDrag) return;
  const path = buildVHPath(lineDrag.start, lineDrag.cur);
}

function drawCharAtCell(r, c, ch) { ascii[r][c] = ch; }


//     ██████  ██    ██ ██     ██   ██  █████  ███    ██ ██████  ██      ███████ ██████  ███████ 
//    ██       ██    ██ ██     ██   ██ ██   ██ ████   ██ ██   ██ ██      ██      ██   ██ ██      
//    ██   ███ ██    ██ ██     ███████ ███████ ██ ██  ██ ██   ██ ██      █████   ██████  ███████ 
//    ██    ██ ██    ██ ██     ██   ██ ██   ██ ██  ██ ██ ██   ██ ██      ██      ██   ██      ██ 
//     ██████   ██████  ██     ██   ██ ██   ██ ██   ████ ██████  ███████ ███████ ██   ██ ███████ 


// Events
function setHoverFromEvent(e) {
hoverCell = canvasPointToCell(e.clientX, e.clientY);
if (pasteDrag && hoverCell) pasteDrag.anchor = { r: hoverCell.r, c: hoverCell.c };
updateUI();
}

// Sidebar toggle
toggleSidebar.addEventListener('click', () => {
sidebarOpen = !sidebarOpen;
sidebar.classList.toggle('closed', !sidebarOpen);
updateUI();
scheduleResize();
});

// Mode buttons
modeFreeform.addEventListener('click', () => {
tool = 'freeform';
// Requirement: selection box disappears in Freeform mode
selection = null;
selectDrag = null;
moveDrag = null;
updateUI();
draw();
});
modeSelect.addEventListener('click', () => {
tool = 'select';
if (isDrawing) endFreeform();
updateUI();
draw();
});

modeLine.addEventListener('click', () => {
  tool = 'line';

  // Clear selection / move state when entering Line mode
  selection = null;
  selectDrag = null;
  moveDrag = null;

  // Cancel any ongoing preview modes
  lineDrag = null;
  cancelPaste?.();

  updateUI();
  draw();
});

// Picker/catalog
pickerBackdrop.addEventListener('click', closePicker);
pickerClose.addEventListener('click', closePicker);
catalogBackdrop.addEventListener('click', closeCatalog);
catalogClose.addEventListener('click', closeCatalog);

pickCharBtn.addEventListener('click', () => { if (op.type !== 'place') op = { type: 'place', ch: '+' }; openPicker(); });
openCatalogBtn.addEventListener('click', () => openCatalog());
eraserBtn.addEventListener('click', () => { op = { type: 'erase' }; updateUI(); });

// Undo/redo
undoBtn.addEventListener('click', doUndo);
redoBtn.addEventListener('click', doRedo);

// Save/load
saveBtn.addEventListener("click", () => {
const raw = serializeToText();
const cleaned = sanitizeForSave(raw);
downloadText(cleaned, "ascii-schema.txt");
});
loadBtn.addEventListener('click', () => fileInput.click());

fileInput.addEventListener("change", async (e) => {
try {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    const raw = await file.text();

    // Expand wide chars (⬤ etc.) so the grid aligns with IDE rendering
    const expanded = expandWideCharsForGrid(raw);

    // Convert to lines (using your existing normalizeNewlines)
    const lines = toLines(expanded); // <-- IMPORTANT

    const stroke = [];

    for (let r = 0; r < ROWS; r++) {
    const line = lines[r] || "";
    for (let c = 0; c < COLS; c++) {
        const prev = ascii[r][c];
        const next = line[c] || " ";
        if (prev !== next) {
        stroke.push({ r, c, prev, next });
        ascii[r][c] = next;
        }
    }
    }

    selection = null;
    selectDrag = null;
    moveDrag = null;
    cancelPaste();

    pushStrokeIfNonEmpty(stroke);
    draw();

    fileInput.value = "";
} catch (err) {
    console.error("Load failed:", err);
    alert("Load failed. See console for details.");
}
});


// Clear
clearBtn.addEventListener('click', () => {
const stroke = [];
for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
    const prev = ascii[r][c];
    if (prev !== ' ') { stroke.push({ r, c, prev, next: ' ' }); ascii[r][c] = ' '; }
    }
}
selection = null; selectDrag = null; moveDrag = null; cancelPaste();
pushStrokeIfNonEmpty(stroke);
draw();
});

// Paste button focuses hidden textarea, then user Cmd/Ctrl+V
pasteBtn.addEventListener('click', () => { pasteSink.value = ''; pasteSink.focus(); });

// Paste capture (also allow direct paste anywhere)
window.addEventListener('paste', (e) => {
const text = e.clipboardData ? expandWideCharsForGrid(e.clipboardData.getData('text/plain')) : '';
if (typeof text === 'string' && text.length > 0) { e.preventDefault(); startPasteWithText(text); canvas.focus(); }
});
pasteSink.addEventListener('paste', (e) => {
const text = e.clipboardData ? expandWideCharsForGrid(e.clipboardData.getData('text/plain')) : '';
if (typeof text === 'string' && text.length > 0) { e.preventDefault(); startPasteWithText(text); canvas.focus(); }
});

// Zoom / pan with wheel
canvas.addEventListener(
"wheel",
(e) => {
e.preventDefault();

// Pinch-zoom on trackpad (Chrome/Safari typically set ctrlKey for pinch)
if (e.ctrlKey) {
    const zoomFactor = Math.exp(-e.deltaY * 0.0015);
    scale = clamp(Number((scale * zoomFactor).toFixed(4)), MIN_SCALE, MAX_SCALE);
    updateUI();
    draw();
    return;
}

// Heuristic: treat "smooth, small deltas" as trackpad scrolling => PAN.
// Treat "large, stepped deltas" as mouse wheel => ZOOM.
const absX = Math.abs(e.deltaX || 0);
const absY = Math.abs(e.deltaY || 0);
const looksLikeTrackpad = absX > 0 || (e.deltaMode === 0 && absY > 0 && absY < 50);

if (looksLikeTrackpad) {
    // Two-finger scroll pans (KiCad-like)
    panX += (e.deltaX || 0) / scale;
    panY += (e.deltaY || 0) / scale;
    updateUI();
    draw();
    return;
}

// Mouse wheel zooms
const zoomFactor = Math.exp(-e.deltaY * 0.0015);
scale = clamp(Number((scale * zoomFactor).toFixed(4)), MIN_SCALE, MAX_SCALE);
updateUI();
draw();
},
{ passive: false }
);


// Mouse
canvas.addEventListener('mousemove', (e) => 
{
    if (panDrag) {
        const dx = e.clientX - panDrag.x;
        const dy = e.clientY - panDrag.y;
        panX = panDrag.panX0 + dx / scale;
        panY = panDrag.panY0 + dy / scale;
        setHoverFromEvent(e);
        draw();
        return;
    }

    setHoverFromEvent(e);
    const cell = canvasPointToCell(e.clientX, e.clientY);

    if (pasteDrag) {
        if (cell) pasteDrag.anchor = { r: cell.r, c: cell.c };
        draw();
        return;
    }

    if (tool === 'freeform') moveFreeform(cell);
    else if (tool === 'line') moveLine(cell);
    else moveSelect(cell);

});

canvas.addEventListener("mousedown", (e) => 
{
    // Middle OR right mouse drag = pan
    if (e.button === 1 || e.button === 2) 
    {
        e.preventDefault();
        panDrag = { x: e.clientX, y: e.clientY, panX0: panX, panY0: panY };
        canvas.style.cursor = "grabbing";
        return;
    }

    if (e.button !== 0) return;

    if (e.button === 1) {
        e.preventDefault();
        panDrag = { x: e.clientX, y: e.clientY, panX0: panX, panY0: panY };
        canvas.style.cursor = 'grabbing';
        return;
    }

    if (e.button !== 0) return;
    canvas.focus();
    setHoverFromEvent(e);
    const cell = canvasPointToCell(e.clientX, e.clientY);

    if (pasteDrag) { commitPasteAt(cell); return; }

    if (tool === 'freeform') beginFreeform(cell);
    else if (tool === 'line') beginLine(cell);
    else beginSelect(cell);

});

window.addEventListener('mouseup', () => 
{
  if (panDrag) { panDrag = null; canvas.style.cursor = ''; return; }
  if (pasteDrag) return;

  if (tool === 'line' && lineDrag) { endLine(); return; }

  if (isDrawing) endFreeform();
  if (selectDrag || moveDrag) endSelect();
});

canvas.addEventListener('mouseleave', () => {
  if (panDrag) { panDrag = null; canvas.style.cursor = ''; }
  hoverCell = null;
  updateUI();
  if (pasteDrag) return;

  if (tool === 'line' && lineDrag) { cancelLine(); return; }

  if (isDrawing) endFreeform();
  if (selectDrag || moveDrag) endSelect();
});


canvas.addEventListener('contextmenu', (e) => e.preventDefault());

// Shortcuts
window.addEventListener('keydown', (e) => {
const isMac = /mac/i.test(navigator.platform);
const mod = isMac ? e.metaKey : e.ctrlKey;
if (e.key === 'Escape') { if (pasteDrag) { e.preventDefault(); cancelPaste(); } return; }

if(e.key.toLowerCase() === 'r' && pasteDrag!=null) // r for rotating
{ 
    const it = catalogItemByUID(pasteDrag.item_data.uid);
    if(it)
    {
        pasteDrag.item_data.rotation = (pasteDrag.item_data.rotation+1) % it.text_data.length;
        const text_data = it.text_data[ pasteDrag.item_data.rotation ];
        startPasteWithText(expandWideCharsForGrid(text_data) || '');
    }
}

if (!mod) return;  

// Cmd / Ctrl + ...
const k = String(e.key || '').toLowerCase();

if (k === 'z' && !e.shiftKey) { e.preventDefault(); doUndo(); }
else if (k === 'z' && e.shiftKey) { e.preventDefault(); doRedo(); }
else if (k === 'v') {
    pasteSink.value = '';
    pasteSink.focus(); 
    }
}, { passive: false });

// Resize observer (debounced via rAF)
let resizeRaf = null;
function scheduleResize() {
if (resizeRaf != null) return;
resizeRaf = requestAnimationFrame(() => {
    resizeRaf = null;
    const next = computeStageSize();
    if (next.w === stageSize.w && next.h === stageSize.h) return;
    stageSize = next;
    stage.style.width = stageSize.w + 'px';
    stage.style.height = stageSize.h + 'px';
    syncCanvasBufferToStage();
    draw();
});
}

const ro = new ResizeObserver(() => scheduleResize());
ro.observe(container);


//    ███████  █████  ███    ██ ██ ████████ ██    ██      ██████ ██   ██ ███████  ██████ ██   ██ 
//    ██      ██   ██ ████   ██ ██    ██     ██  ██      ██      ██   ██ ██      ██      ██  ██  
//    ███████ ███████ ██ ██  ██ ██    ██      ████       ██      ███████ █████   ██      █████   
//         ██ ██   ██ ██  ██ ██ ██    ██       ██        ██      ██   ██ ██      ██      ██  ██  
//    ███████ ██   ██ ██   ████ ██    ██       ██         ██████ ██   ██ ███████  ██████ ██   ██ 


  </script>

  <script src="AsciiCAD_SanityCheck.js"></script>
</body>
</html>
